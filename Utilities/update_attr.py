import asyncio

from dotenv import load_dotenv
from openai import AsyncOpenAI
import textwrap
from pydantic import BaseModel
from typing import List, Dict, TypeVar, Any

load_dotenv()
client = AsyncOpenAI()
V = TypeVar("V")

physical_condition_messages: List[Dict[str, V]] = []
money_messages: List[Dict[str, V]] = []
relationship_messages: List[Dict[str, V]] = []
inventory_messages: List[Dict[str, V]] = []
hp_messages: List[Dict[str, V]] = []
current_location_messages: List[Dict[str, V]] = []

key_events_messages: List[Dict[str, V]] = []
environment_messages: List[Dict[str, V]] = []


class InventoryResponse(BaseModel):
    used_item: bool
    items_list: list[str]


async def get_response(messages: List[Dict[str, Any]]) -> str:
    """Sends a list of messages to the OpenAI API and retrieves the response.

    :param messages: A list of message dictionaries, where each dictionary
                     contains keys like 'role' (e.g., 'system', 'user', 'assistant')
                     and 'content' (the actual message text).
    :return: A string containing the response from the GPT-4o-mini API based on the
             input messages
    """
    response = await client.chat.completions.create(
        model="gpt-4o-mini",
        messages=messages,
        temperature=1,
        max_tokens=1400,
        top_p=1,
        frequency_penalty=0,
        presence_penalty=0,
        response_format={
            "type": "text"
        }
    )
    return response.choices[0].message.content


def append_msg(message: str, messages_array: List[Dict[str, Any]], role_type: str) -> None:
    """Appends a new system, user or assistant message to the messages array.

    :param message: The message content from the system, user, or assistant as a string.
                    - system: This is the system instruction that the assistant will follow.
                    - user: This is the text that the user is contributing to the conversation.
                    - assistant: This is the response generated by the assistant.
    :param messages_array: A list of dictionaries that stores the conversation history.
                           Each dictionary in the list contains information such as
                           the role of the message (user or assistant) and the message content.
    :param role_type: A string containing the message's role (system, user or assistant).
    :return: None
    """
    messages_array.append(
        {
            "role": role_type,
            "content": [
                {
                    "type": "text",
                    "text": message
                }
            ]
        }
    )


def begin_update_attr() -> None:
    """Begins the attribute updates by appending system instructions to respective message arrays for each attribute.

    :return: None
    """
    # Physical Condition
    physical_condition_system_instructions: str = textwrap.dedent("""
    Read the given story and update the physical condition of characters based on any events that affect them.
    
    - You will be provided with a story and a list of characters including their current physical condition.
    - Identify any changes in the physical condition of characters as conveyed by the story and update their status accordingly.
    - Use "Healthy," "Injured," or other relevant descriptors to indicate conditions.
    - If no changes are needed, return the string "False" only.
    
    # Steps
    
    1. **Understand Roles**:
       - Identify the main character referred to as "you" in the story, always using ID 1.
    
    2. **Analyze the Story**:
       - Read the story carefully to detect any events or actions that affect characters' health conditions.
       - Pay attention to keywords or phrases indicating physical changes, such as injuries or recoveries.
    
    3. **Compare and Update**:
       - Compare the current physical condition with the new condition inferred.
       - Only update if there is a change.
    
    4. **Properly Format Output**:
       - If there's no change for all characters, return "False."
       - If changes occur, format the output as `<ID> = <new_status>`.
    
    # Output Format
    
    - If no changes are required: "False"
    - If conditions change: `<ID> = <new_status>`
    
    # Examples
    
    **Example 1**  
    Input:  
    **Story**  
    "Despite the fierce battle, John remained unscathed, but he witnessed Sarah taking a fall, resulting in a minor sprain."  
    
    **Character Dictionaries**  
    ```
    [
      {id: 1, name: john, physical_condition: healthy},
      {id: 2, name: sarah, physical_condition: healthy}
    ]
    ```  
    
    Output:  
    `2 = Injured`
    
    **Example 2**  
    Input:  
    **Story**  
    "Walking through the forest, you feel invigorated by the fresh air and beautiful scenery."  
    
    **Character Dictionaries**  
    ```
    [
      {id: 1, name: john, physical_condition: healthy}
    ]
    ```  
    
    Output:  
    "False"
    
    # Notes
    
    - In the case of ambiguous physical conditions, rely on context within the story to select the most logical status.
    - Ensure no character status is updated if they retain the same physical condition described in the dictionary.
    - Avoid unnecessary updates if the condition remains unchanged.
    - Return either "False" or the schema only, DON'T give any justification. Please follow the output format above.
    """)
    append_msg(physical_condition_system_instructions, physical_condition_messages, "system")

    # Money
    money_system_instructions: str = textwrap.dedent("""
    Money refers to the currency of the world.                                              
    Update a character's money based on a given story, ensuring updates only occur with absolute confirmation of a transaction.

    In this task, you will receive a story and character dictionaries. Each dictionary contains a character's ID, name, and current money. Not all characters in the dictionary may be involved in a transaction described in the story.
    
    # Steps
    
    1. **Read the Story:** Carefully examine the story to identify any references to monetary exchanges involving characters.
    2. **Identify Transactions:** Look for explicit confirmation of a transaction where a character’s money decreases or increases.
    3. **Validate Characters:** Ensure the character involved in the transaction is in the provided character dictionaries.
    4. **Update Money:** Only update a character's money in their respective dictionary if a transaction is confirmed in the story.
    5. **Generate Output:** Format the output based on the confirmed transaction.
    
    # Output Format
    
    - If no updates occur, return: "False"
    - If there are updates, return a string for each transaction:
      - To indicate an increase: <id> += <amount>
      - To indicate a decrease: <id> -= <amount>
    - Do not return any additional information or text.
    
    # Examples
    
    **Example 1:**
    
    **Input:**
    - Story: "Alice bought a book for 15 dollars from Bob."
    - Characters: 
      - `{ "ID": "1", "name": "Alice", "money": 50 }`
      - `{ "ID": "2", "name": "Bob", "money": 30 }`
    
    **Output:**
    1 -= 15
    2 += 15
    
    (In this case, there is a clear transaction where Alice loses money and Bob gains money.)
    
    **Example 2:**
    
    **Input:**
    - Story: "Alice was asked about the price of the book. "The price of the book is 10 coins", said Alice."
    - Characters:
      - `{ "ID": "1", "name": "Alice", "money": 50 }`
      - `{ "ID": "2", "name": "Bob", "money": 30 }`
    
    **Output:**
    False
    
    (The story discusses the price but doesn't confirm any transaction, so no update happens and "False" is returned.) 
    
    # Notes
    
    - Emphasize confirmation of the transaction before updating.
    - Conversations or planning that mention money but do not confirm a transaction should not trigger an update.
    - Consider edge cases where multiple transactions are confirmed in the story and ensure each is captured correctly.
    - Return either "False" or the schema only, DON'T give any justification. Please follow the output format above.
    """)
    append_msg(money_system_instructions, money_messages, "system")

    # Relationship
    relationship_system_instructions: str = textwrap.dedent("""
    **Steps:**
    1. You are given a story and character JSON dictionaries.
    2. Read through the story and return a low-level language schema if a "relationship" in a Character JSON dictionary needs updating. This schema uses = for variable assignment and <> as a placeholder.
    3. The second-person pronouns refer to the Main Character (ID: 1).
    4. When updating the "relationship" between characters, return a low-level language schema for both of the characters accordingly.
    5. If no "relationship" needs updating, return "False".
    6. The low-level language schema should strictly follow this format: <ID> = (<other_character_ID>, <relationship_type>)
        a. <ID> is the id of the character that we are updating (character A).
        b. <other_character_ID> is the id of the character that character A has a relationship with (character B).
        c. <relationship_type> describes the relationship between the two characters (character A and B), use 1-2 words to describe their relationship.
    
    Your **response format** should ONLY be either:
    1. False
    2. <schemas>
       a. <> is a placeholder - REPLACE this according to the steps above.
    """)
    append_msg(relationship_system_instructions, relationship_messages, "system")

    # Inventory
    inventory_system_instructions: str = textwrap.dedent("""
    Inventory is a list of items a character has on them throughout the story. The inventory DOESN'T include money.

    **Steps:**
    1. You are given a story and character JSON dictionaries.
    2. Update the inventory attribute based on the given story. Only return a low-level language schema for "inventory". This schema uses = for variable assignment, basic maths (+-), and <> as a placeholder.
    3. The second-person pronouns refer to the Main Character (ID: 1).
    4. If no updates are needed, return "False" and nothing else.
    5. When any character OBTAINS an item, the low-level language schema should strictly follow this format: <ID> += <item>
        a. <ID> is the respective character's id.
    6. When any character LOSES an item, the low-level language schema should strictly follow this format: <ID> -= <item>
        a. <ID> is the respective character's id.
    
    Your **response format** should ONLY be either:
    1. False
    2. <schemas>
       a. <> is a placeholder - REPLACE this according to the steps above.
    """)
    append_msg(inventory_system_instructions, inventory_messages, "system")

    # HP
    hp_system_instructions: str = textwrap.dedent("""
    “HP” determines how much health a character has.
    Update character HP based on a given story and character dictionary.

    You will receive a story and a list of character dictionaries as inputs. Each dictionary contains the following keys: ID, name, physical_condition, and HP. The dictionaries may include characters not involved in the current story.
    
    - If a character loses HP in the story (e.g. gets injured):
      - Return "ONLY `<id> -= <amount>`" where <id> is the character's ID and <amount> is the HP lost.
      - If the amount of HP lost is unclear, generate a random, sensible amount (e.g., a nosebleed should not result in losing all HP, but just a little).
    
    - If a character gains HP (e.g., heals using an item):
      - Return "ONLY `<id> += <amount>`" where <id> is the character's ID and <amount> is the HP gained.
      - If the amount of HP gained is unclear, generate a random amount.
    
    - If no character's HP needs updating, return "False" ONLY.
    
    - Eating or drinking might result in healing, but it depends on the context. 
    
    # Steps
    
    1. Analyze the story to identify characters involved and any events affecting their HP.
    2. Match identified characters with their corresponding dictionaries using IDs.
    3. Determine HP changes as explicitly stated in the story or generate random sensible amounts if not clear.
    4. Return the appropriate HP update statement for each affected character.
    5. If no changes are necessary, return "False".
    
    # Output Format
    
    - Use the format `<id> -= <amount>` for HP loss.
    - Use the format `<id> += <amount>` for HP gain.
    - Return "False" if no HP changes are needed.
    
    # Examples
    
    **Example 1:**
    
    _Input:_
    - Story: "In the battle, John took a heavy hit."
    - Characters: [{"ID": "123", "name": "John", "physical_condition": "injured", "HP": 50}, {"ID": "456", "name": "Jane", "physical_condition": "healthy", "HP": 70}]
    
    _Output:_
    - "123 -= 10" (if a heavy hit typically reduces HP by a random amount such as 10)
    
    **Example 2:**
    
    _Input:_
    - Story: "Anna found a potion and healed."
    - Characters: [{"ID": "789", "name": "Anna", "physical_condition": "recovering", "HP": 30}]
    
    _Output:_
    - "789 += 15" (random sensible HP gain)
    
    **Example 3:**
    
    _Input:_
    - Story: "The day was calm, and everyone rested peacefully."
    - Characters: [{"ID": "123", "name": "John", "physical_condition": "healthy", "HP": 50}]
    
    _Output:_
    - "False"
    
    # Notes
    
    - Ensure that the amount of HP updates (loss or gain) is contextually appropriate to events in the story.
    - Use sensible judgment when generating random amounts based on the described events in the story.
    - When a character eats or drinks something, consider it as HP gained.
    - Return either "False" or the schema only, DON'T give any justification. Please follow the output format above.
    """)
    append_msg(hp_system_instructions, hp_messages, "system")

    # Current_location
    current_location_system_instructions: str = textwrap.dedent("""
    Current_location is defined as the current location of the character. The current location should be described as specific as possible based on the story.

    **Steps:** 
    1. You are given a story.
    2. Read through the story and return a low-level language schema if a "current_location" in a Character JSON dictionary needs updating. Use the characters' IDs given in the character JSON dictionaries. This schema uses = for variable assignment and <> as a placeholder.
    3. The second-person pronouns refer to the Main Character (ID: 1).
    4. The low-level language schema should strictly follow this format: <ID> = <new_location>
        a. <ID> is the respective character's id.
        b. <new_location> shows the current location of a character. If two characters are in the same location, they should have the same current_location.
    5. If no "current_location" needs updating, return "False".
    
    Your **response format** should ONLY be either:
    1. False
    2. <schemas>
       a. <> is a placeholder - REPLACE this according to the steps above.
    """)
    append_msg(current_location_system_instructions, current_location_messages, "system")

    # Key_events
    key_events_system_instructions: str = textwrap.dedent("""
    key_events is defined as the summary of the current story response.

    **Steps:** 
    1. You are given a story.
    2. Read through the story and return ONLY a summarised version of it.
    3. Keep the summary to around 2 - 3 sentences long.
    """)
    append_msg(key_events_system_instructions, key_events_messages, "system")

    # Environment
    environment_system_instructions: str = textwrap.dedent("""
    The environment describes the location the Main Character is in. It is a detailed description but short (1 sentence long).
    **Steps:** 
    1. You are given a story.
    2. The main character has moved to a new location and the environment needs updating.
    3. Read through the story and return ONLY the new description of the new environment.
    """)
    append_msg(environment_system_instructions, environment_messages, "system")


# Physical Condition
async def get_physical_condition_update(story: str, characters: str) -> str:
    """Retrieves updates required for the characters' physical condition based on the provided story.

    This function sends a prompt to ChatGPT to determine whether there are any changes to the characters'
    physical conditions based on recent story events. It assesses whether characters have been injured,
    affected by status effects, or have returned to a healthy state.

    :param story: A string of the 3 most recent story events.
    :param characters: A JSON string representation of the characters, including their ID, name, and
                       current physical condition.
    :return: A string detailing the updates needed for characters whose physical condition has changed,
             formatted according to the specified schema.
    """
    prompt: str = textwrap.dedent(f"""
    **Story:**
    {story}
    **Character JSON Dictionaries:**
    {characters}
    
    - physical_condition should change if a character gets injured or affected by status effects based on the story.
      - Note: You need to first check if the character in the Character JSON Dictionaries based on their name.
    - If a character becomes healthy or in normal state, the physical_condition should be healthy.
    """)
    append_msg(prompt, physical_condition_messages, "user")
    response: str = await get_response(physical_condition_messages)
    append_msg(response, physical_condition_messages, "assistant")
    return response


# Money
async def get_money_update(story: str, characters: str) -> str:
    """Retrieves updates required for the characters' money based on the provided story.

    This function sends a prompt to ChatGPT to determine whether there are any changes to the characters'
    money based on recent story events. It assesses whether characters have gained or lost money.

    :param story: A string of the current story.
    :param characters: A JSON string representation of the characters, including their ID, name, and
                       current money amount.
    :return: A string detailing the updates needed for characters whose money values have changed,
             formatted according to the specified schema.
    """
    prompt: str = textwrap.dedent(f"""
    **Story:**
    {story}
    **Character JSON Dictionaries:**
    {characters}
    - If a transaction HASN'T HAPPENED yet (NO CONFIRMATION), DON'T UPDATE any of the dictionaries.
    """)
    append_msg(prompt, money_messages, "user")
    response: str = await get_response(money_messages)
    append_msg(response, money_messages, "assistant")
    return response


# Relationship
async def get_relationship_update(story: str, characters: str) -> str:
    """Retrieves updates required for the characters' relationships based on the provided story.

    This function sends a prompt to ChatGPT to determine whether there are any changes to the characters'
    relationships based on recent story events. It assesses whether the relationship between two characters
    have changed.

    :param story: A string of the 3 most recent story events.
    :param characters: A JSON string representation of the characters, including their ID, name, and
                       current relationships.
    :return: A string detailing the updates needed for characters whose relationships has changed, formatted
            according to the specified schema.
    """
    prompt: str = textwrap.dedent(f"""
    **Story:**
    {story}
    **Character JSON Dictionaries:**
    {characters}
    """)
    append_msg(prompt, relationship_messages, "user")
    response: str = await get_response(relationship_messages)
    append_msg(response, relationship_messages, "assistant")
    return response


# Inventory
async def get_inventory_update(story: str, characters: str) -> str:
    """Retrieves updates required for the characters' inventory based on the provided story.

    This function sends a prompt to ChatGPT to determine whether there are any changes to the characters'
    inventory based on recent story events. It assesses whether the characters have gained or lost an item.

    :param story: A string of the 3 most recent story events.
    :param characters: A JSON string representation of the characters, including their ID, name, and
                       current inventory.
    :return: A string detailing the updates needed for characters whose inventory has changed, formatted
             according to the specified schema.
    """
    prompt: str = textwrap.dedent(f"""
    **Story:**
    {story}
    **Character JSON Dictionaries:**
    {characters}
    - If there's NO CONFIRMATION that a character HASN'T obtained or lost an item yet, DON'T UPDATE any of the dictionaries.
    - If the character has purchased some items (transaction confirmed), please remember to add those items to their inventory.
    """)
    append_msg(prompt, inventory_messages, "user")
    response: str = await get_response(inventory_messages)
    append_msg(response, inventory_messages, "assistant")
    return response


# HP
async def get_hp_update(story: str, characters: str) -> str:
    """Retrieves updates required for the characters' HP based on the provided story.

    This function sends a prompt to ChatGPT to determine whether there are any changes to the characters'
    HP based on recent story events. It assesses whether the characters have gained or lost HP.

    :param story: A string of the 3 most recent story events.
    :param characters: A JSON string representation of the characters, including their ID, name,
                       physical_condition, and current HP.
    :return: A string detailing the updates needed for characters whose HP has changed, formatted according
             to the specified schema.
    """
    prompt: str = textwrap.dedent(f"""
    **Story:**
    {story}
    **Character JSON Dictionaries:**
    {characters}
    """)
    append_msg(prompt, hp_messages, "user")
    response: str = await get_response(hp_messages)
    append_msg(response, hp_messages, "assistant")
    return response


# Current_location
async def get_current_location_update(story: str, characters: str) -> str:
    """Retrieves updates required for the characters' current location based on the provided story.

    This function sends a prompt to ChatGPT to determine whether there are any changes to the characters'
    current_location based on recent story events. It assesses whether the characters have moved locations.

    :param story: A string of the 3 most recent story events.
    :param characters: A JSON string representation of the characters, including their ID, name, and
                       current location.
    :return: A string detailing the updates needed for characters whose current location has changed,
             formatted according to the specified schema.
    """
    prompt: str = textwrap.dedent(f"""
    **Story:**
    {story}
    **Character JSON Dictionaries:**
    {characters}
    """)
    append_msg(prompt, current_location_messages, "user")
    response: str = await get_response(current_location_messages)
    append_msg(response, current_location_messages, "assistant")
    return response


# Environment
async def get_environment(story: str) -> str:
    """Retrieves an update to the environment based on the provided story.

    This function sends a prompt to ChatGPT to determine how the environment changes
    according to the main character's current location. It generates a description of the
    new environment the main character finds themselves in.

    :param story: A string of the 3 most recent story events.
    :return: A string describing the updated environment where the main character is located.
    """
    prompt: str = textwrap.dedent(f"""
    **Story:**
    {story}
    """)
    append_msg(prompt, environment_messages, "user")
    response: str = await get_response(environment_messages)
    append_msg(response, environment_messages, "assistant")
    return response


# Key_events
async def get_key_events(story: str) -> str:
    """Retrieves a summary of the key events based on the provided story.

    This function sends a prompt to ChatGPT to generate a concise summary of the story,
    highlighting the key events that occurred.

    :param story: A string of the current story.
    :return: A string summarising the key events from the provided story.
    """
    prompt: str = textwrap.dedent(f"""
    **Story:**
    {story}
    """)
    append_msg(prompt, key_events_messages, "user")
    response: str = await get_response(key_events_messages)
    append_msg(response, key_events_messages, "assistant")
    return response


async def requery(attribute: str, story: str, char_dicts: str, update_line: str) -> str:
    """Sends a requery to ChatGPT to correct an improperly formatted update line.

    This function requeries a previously incorrect character attribute update line to ChatGPT,
    providing schema instructions based on the attribute type. The goal is to return a corrected
    update line in the proper schema format.

    :param attribute: The attribute for which the update schema should adhere to.
    :param story: A string of the 3 most recent story events.
    :param char_dicts: A JSON string representation of the characters, including their ID, name,
                       and the attribute relevant to the update.
    :param update_line: The incorrectly formatted character attribute update line that needs fixing.
    :return: A string containing the corrected update line in the appropriate format.
    """
    # set the instructions and message for the correct attribute
    messages = []
    if attribute == "physical_condition":
        instructions: str = "<ID> = <new_status>"
    elif attribute == "money":
        instructions = "<ID> += <amount> or <ID> -= <amount>"
    elif attribute == "relationship":
        instructions = '<ID> = (<other_character_ID>, <relationship_type>)'
    elif attribute == "inventory":
        instructions = "<ID> += <item> or <ID> -= <item>"
    elif attribute == "hp":
        instructions = "<ID> += <new_hp> or <ID> -= <new_hp>"
    else:  # current_location
        instructions = "<ID> = <new_location>"

    prompt: str = textwrap.dedent(f"""
    Invalid format. Please FIX the schema FORMAT, as instructed below, and use the character's ID instead of their name.
    Schema FORMAT should follow this: {instructions}
    Return ONLY this line after FIXING it: {update_line}

    **Story:**
    {story}
    **Character JSON Dictionaries:**
    {char_dicts}
    """)
    append_msg(prompt, messages, "user")
    response: str = await get_response(messages)
    return response


async def check_char_inventory(user_input: str) -> InventoryResponse:
    """Prompts ChatGPT to check if any items are being used by the main character based on the user's input.

    :param user_input: A string representing the user's input.
    :return: An InventoryResponse object:
             - used_item: bool, determines whether an item was used or not
             - items_list: list[str], a list of items used.
    """
    messages = []
    sys_instruction: str = textwrap.dedent("""
        Determine if a user input is specifying the use of an item. If the input indicates using an item, return "True" along with a list of items mentioned. If the input does not suggest using an item, return "False".

        # Steps
        
        1. **Parse the Input**: Understand the context and structure of the user input to identify any items mentioned.
        2. **Identify Usage**: Determine if the user input suggests that the mentioned item(s) are being "used". Key terms indicating "use" should be emphasized.
        3. **Exclude Non-Usage Contexts**: Ensure the input does not relate to buying or exchanging items. Focus solely on utilization.
        4. **Generate Output**: Based on the analysis, conclude with either "True" and a list of items, or "False".
        
        # Output Format
        
        - If items are being used, output:
          - "True"
          - A JSON list of item(s).
        
        - If no items are being used, output:
          - "False"
          - []
        
        # Examples
        
        **Example 1:**
        
        - **Input**: "I am using the new software package."
        - **Output**: 
        True, ["software package"]
        
        **Example 2:**
        
        - **Input**: "I just purchased a new laptop."
        - **Output**: 
        False, []
        
        **Example 3:**
        
        - **Input**: "I exchanged my old phone for a new one."
        - **Output**: 
        False, []
        
        # Notes
        
        - Emphasize verbs or phrases like “using,” “utilizing,” or “applying” as indicators of item usage.
        - Exclude phrases like "buying," "purchasing," "selling," "exchanging," etc.
        - Avoid returning names of characters.
    """)
    append_msg(sys_instruction, messages, "system")

    prompt: str = textwrap.dedent(f"""
        **User Input**
        {user_input}
        """)
    append_msg(prompt, messages, "user")
    completion = await client.beta.chat.completions.parse(
        model="gpt-4o-mini",
        messages=messages,
        response_format=InventoryResponse,
    )

    return completion.choices[0].message.parsed


def reset_chat(count: int) -> None:
    """Resets the message history for all attribute message arrays after every 3 update prompt calls.

    :param count: The number of times the update prompts were called.
    :return: None
    """
    global physical_condition_messages, money_messages, relationship_messages, inventory_messages, hp_messages, current_location_messages, key_events_messages, environment_messages
    if count >= 3:
        physical_condition_messages = physical_condition_messages[:1]
        money_messages = money_messages[:1]
        relationship_messages = relationship_messages[:1]
        inventory_messages = inventory_messages[:1]
        hp_messages = hp_messages[:1]
        current_location_messages = current_location_messages[:1]
        key_events_messages = key_events_messages[:1]
        environment_messages = environment_messages[:1]
